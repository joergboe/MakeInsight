# How to produce rules automatically

# Use:
# make -f 80_automation.mk USE=canned-recipe
# make -f 80_automation.mk clean

# make -f 80_automation.mk USE=call
# make -f 80_automation.mk clean

# make -f 80_automation.mk USE=eval
# make -f 80_automation.mk clean

# See: https://www.gnu.org/software/make/manual/html_node/Canned-Recipes.html#index-canned-recipes

targets ::= file1 file2 file3

.PHONY: all
all: $(targets)

USE ?= canned-recipe
ifeq (canned-recipe,$(USE))

$(info Rules using a canned recipe)

define recipe
@echo "Running rule $@"
touch $@
@echo "Every line uses a separate shell pid=$$$$"
@echo "Every line uses a separate shell pid=$$$$"
endef

$(targets): %:
	$(recipe)

else ifeq (call,$(USE))

$(info Rules generated by a function call)
$(warning Error is expected.)

define rule
$(1):
	@echo "Running rule $@"
	touch $@
	@echo "Every line uses a separate shell pid=$$$$"
	@echo "Every line uses a separate shell pid=$$$$"
endef

# target and prerequisites are not properly parsed in function context
$(foreach target,$(targets),$(call rule,$(target)))
# *** multiple target patterns.  Stop.

else ifeq (eval,$(USE))

$(info Rules generated by eval)

define rule2
$(target):
	@echo "Running rule $$@"
	touch $$@
	@echo "Every line uses a separate shell pid=$$$$$$$$"
	@echo "Every line uses a separate shell pid=$$$$$$$$"
endef

$(foreach target,$(targets),$(eval $(rule2)))

else

$(error Wrong value for USE - must be recipe|call|eval but is '$(USE)')

endif

.PHONY: clean
clean:;rm -f $(targets)
